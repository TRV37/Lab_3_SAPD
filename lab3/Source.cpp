#include <iostream>
#include <vector>

void sortBalls(std::vector<int>& balls) 
{
    int start = 0;
    int end = balls.size() - 1;
    int index = 0;

    while (index <= end) 
    {
        if (balls[index] == 0) 
        {
            std::swap(balls[start], balls[index]);
            start++;
            index++;
        }
        else if (balls[index] == 1) 
            index++;
        
        else 
            std::swap(balls[index], balls[end]);
            end--;
        
    }
}

int main() 
{
    std::vector<int> balls = { 2, 2, 1, 1, 0, 0 };
    sortBalls(balls);

    for (int ball : balls) {
        std::cout << ball << " ";
    }

    return 0;
}

//Временная сложность: Порядок сложности для алгоритма сортировки шаров:
//Лучший случай: O(n), где n - количество шаров. Это происходит, когда все шары уже отсортированы. В этом случае алгоритм просто проходит через каждый шар один раз.
//Средний случай: O(n), где n - количество шаров. Поскольку алгоритм всегда проходит через каждый шар один раз, независимо от того, насколько хорошо отсортированы шары.
//Худший случай: O(n), где n - количество шаров. Это происходит, когда все шары отсортированы в обратном порядке. В этом случае алгоритм все равно проходит через каждый шар один раз.
//Пространственная сложность: O(1). Этот алгоритм не использует дополнительное пространство, отличное от входного массива, поэтому его пространственная сложность является константой.



/*

#include <iostream>
#include <vector>

void sortBalls(std::vector<int>& balls) 
{
    int red = 0;
    int white = 0;
    int blue = 0;

    for (int ball : balls) 
    {
        if (ball == 0) red++;
        else if (ball == 1) white++;
        else blue++;
    }

    for (int i = 0; i < red; i++) balls[i] = 0;
    for (int i = red; i < red + white; i++) balls[i] = 1;
    for (int i = red + white; i < balls.size(); i++) balls[i] = 2;
}

int main() 
{
    std::vector<int> balls = {2, 2, 1, 1, 0, 0};
    sortBalls(balls);

    for (int ball : balls) 
        std::cout << ball << " ";
    

    return 0;
}


//Временная сложность: Порядок сложности для алгоритма сортировки шаров:
//Лучший случай: O(n), где n - количество шаров. Это происходит, когда все шары уже отсортированы. В этом случае алгоритм просто проходит через каждый шар один раз.
//Средний случай: O(n), где n - количество шаров. Поскольку алгоритм всегда проходит через каждый шар один раз, независимо от того, насколько хорошо отсортированы шары.
//Худший случай: O(n), где n - количество шаров. Это происходит, когда все шары отсортированы в обратном порядке. В этом случае алгоритм все равно проходит через каждый шар один раз.
//Пространственная сложность: O(1). Этот алгоритм использует только несколько переменных для подсчета количества каждого типа шаров, поэтому его пространственная сложность является константой.

*/


/*

#include <iostream>
#include <vector>

void sortBalls(std::vector<int>& balls) 
{
    int n = balls.size();
    for (int i = 0; i < n-1; i++) 
        for (int j = 0; j < n-i-1; j++) 
            if (balls[j] > balls[j+1]) 
                std::swap(balls[j], balls[j+1]);
            
        
    
}

int main() 
{
    std::vector<int> balls = {2, 2, 1, 1, 0, 0}; // 2 - синий, 1 - белый, 0 - красный
    sortBalls(balls);
    for(int i=0; i < balls.size(); i++)
        std::cout<<balls[i]<<" ";
    
    return 0;
}




//Временная сложность: Порядок сложности для алгоритма сортировки шаров
//Лучший случай: O(n). Если массив уже отсортирован, алгоритм просто проходит по массиву один раз и не делает ни одного обмена. Таким образом, в лучшем случае временная сложность составляет O(n).
//Средний случай: O(n^2). В среднем алгоритму придется пройти по массиву n раз для каждого из n элементов, поэтому временная сложность составляет O(n^2).
//Худший случай: O(n^2). Если массив отсортирован в обратном порядке, алгоритму придется сделать максимальное количество обменов. Таким образом, в худшем случае временная сложность также составляет O(n^2).
*/